# 基于轻量级Web服务器的KV存储演示系统

该项目整合 [轻量级Linux高性能Web服务器](https://github.com/UtopianYouth/webserver) 和 [kvstore](https://github.com/UtopianYouth/kvstore)，基于**Reactor网络模型 + 线程池**架构，实现了一个高性能、支持Web界面交互的键值存储演示系统。系统能够解析HTTP请求（GET/POST）和KV命令，提供三种不同数据结构的存储引擎，并通过RESTful API与前端实现数据交互。

## 一、项目简介

### 1.1 技术栈

**后端**

| 技术类别 | 技术选型 | 说明 |
|---------|---------|------|
| **编程语言** | C++17 | 使用现代C++特性，包括智能指针、Lambda表达式、函数封装器等 |
| **网络模型** | Reactor模式 | 主线程负责I/O多路复用，工作线程处理业务逻辑 |
| **I/O多路复用** | epoll (ET模式) | 边缘触发 + 非阻塞I/O，实现高并发网络通信 |
| **并发处理** | 线程池 | 基于阻塞队列 + 条件变量实现，避免频繁创建/销毁线程 |
| **HTTP解析** | 有限状态机 | 主从状态机配合，高效解析HTTP请求行/请求头/请求体 |
| **定时器** | 升序双向链表 | 管理非活跃连接，定期清理超时客户端 |
| **线程同步** | 读写锁 (shared_mutex) | 细粒度锁保护KV数据结构，读操作并发，写操作互斥 |
| **存储引擎** | Array / Hash / RBTree | 三种数据结构实现，满足不同场景需求 |
| **内存管理** | mmap + writev | 零拷贝技术，高效处理静态文件响应 |
| **数据交互** | JSON | 前后端基于JSON格式通信 |

**前端**

- **HTML5 + CSS3 + JavaScript**：响应式设计，毛玻璃效果，流畅动画
- **RESTful API**：标准HTTP接口，支持CORS跨域

### 1.2 关键技术

> - 高并发：采用epoll边缘触发模式 + 线程池，支持10K+并发连接；
> - 零拷贝：使用mmap内存映射 + writev分散写，减少数据拷贝开销；
> - 非阻塞I/O：全异步处理，避免线程阻塞，提升系统吞吐量；
>
> - 细粒度锁：每个KV存储引擎独立配备读写锁（std::shared_mutex）；
> - 读写分离：读操作使用共享锁并发执行，写操作使用独占锁保证数据一致性；
> - 无锁优化：不同存储引擎的操作可并发执行，互不干扰；
>
> - 分层架构：网络层（主线程）、业务逻辑层（线程池）、存储层（kv数据结构）清晰分离，易于扩展维护；
> - 面向对象：继承HttpConnection基类实现HttpKvsConnection，复用HTTP解析逻辑；
> - 状态机解析：主从状态机配合，逐行解析HTTP协议，健壮性强。
>

### 1.3 运行环境

- **操作系统**：Linux (推荐 Ubuntu 20.04+)
- **编译器**：GCC/G++ 9.0+ (支持C++17)
- **构建工具**：GNU Make

### 1.4 编译运行步骤

```bash
# 1. 进入到项目根目录，编译项目
make

# 2. 使用make run默认运行在8080端口上
make run 

# 2. 或指定port运行 
./bin/kv-webserver [port]

# 3. 在浏览器输入指定的url访问即可 ==> http://[your_ip]:[your_port]
```

### 1.5 支持的命令
> 基于Array实现的KV存储
>
> ```bash
> SET key value		# 添加键值对
> GET key					# 获取对应键值对的值
> DEL key 				# 删除键值对
> MOD key					# 修改指定键的值
> EXIST key 			# 判断键是否存在
> ```
>
> 基于Hash实现的KV存储
>
> ```bash
> HSET key value		# 添加键值对
> HGET key					# 获取对应键值对的值
> HDEL key 				# 删除键值对
> HMOD key					# 修改指定键的值
> HEXIST key 			# 判断键是否存在
> ```
>
> 基于RBTree实现的KV存储
>
> ```bash
> RSET key value		# 添加键值对
> RGET key					# 获取对应键值对的值
> RDEL key 				# 删除键值对
> RMOD key					# 修改指定键的值
> REXIST key 			# 判断键是否存在
> ```


## 二、后端API接口

当HTTP请求是POST时，前后端交互基于JSON数据格式。

#### 2.1 执行KV命令

```json
POST /api/kv
Content-Type: application/json

{
  "cmd": "SET",
  "key": "name",
  "value": "alice"
}
```

#### 2.2 获取统计信息
```
GET /api/stats
```

响应示例
```json
{
  "status": "OK",
  "data": {
    "array": {"count": 10, "max": 1000, "remaining": 990},
    "hash": {"count": 5, "max": 1000, "remaining": 995},
    "rbtree": {"count": 8, "max": 1000, "remaining": 992}
  }
}
```

## 三、系统设计

### 3.1 数据流

```
┌─────────────────────────────────────────────────────────────┐
│                        客户端浏览器                           │
│              (发送HTTP请求 / 接收HTTP响应)                    │
└─────────────────────┬───────────────────────────────────────┘
                      │ HTTP/1.1 + JSON
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                     主线程 (I/O线程)                          │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  epoll (边缘触发)                                      │  │
│  │  - 监听socket: 接受新连接                              │  │
│  │  - 客户端socket: EPOLLIN/EPOLLOUT事件                  │  │
│  │  - 定时器信号管道: SIGALRM信号处理                     │  │
│  └───────────────────────────────────────────────────────┘  │
│           │                          │                       │
│           │ 新连接                    │ 数据就绪              │
│           ▼                          ▼                       │
│  创建HttpKvsConnection        读取完整HTTP请求               │
│  对象并注册到epoll            将process()加入线程池          │
└─────────────────────────────────────────────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────┐
│                  线程池 (工作线程池)                          │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  阻塞队列 (生产者-消费者模型)                          │  │
│  │  - 条件变量: 队列空时工作线程阻塞等待                   │  │
│  │  - 互斥锁: 保护队列的线程安全                          │  │
│  └───────────────────────────────────────────────────────┘  │
│           │ 取出任务 (std::function<void()>)                │
│           ▼                                                  │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  HttpKvsConnection::process()                         │  │
│  │  1. 有限状态机解析HTTP请求                             │  │
│  │  2. 判断请求类型:                                      │  │
│  │     - POST /api/kv → 处理KV命令                       │  │
│  │     - GET /api/stats → 获取统计信息                   │  │
│  │     - GET 其他路径 → 返回静态文件                      │  │
│  │  3. 生成HTTP响应 (状态行+响应头+响应体)                │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────┐
│                    存储引擎层                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  Array引擎   │  │  Hash引擎    │  │ RBTree引擎   │      │
│  │  + 读写锁    │  │  + 读写锁    │  │  + 读写锁    │      │
│  │  (shared_mtx)│  │  (shared_mtx)│  │ (shared_mtx) │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│       O(n)              O(1)              O(log n)          │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 核心功能

#### 3.2.1 网络层

> - 主线程初始化：创建监听socket，设置为非阻塞，注册到epoll；
> - 接受连接：epoll检测到监听socket可读，accept新连接；
> - 连接注册：为新连接创建`HttpKvsConnection`对象，设置非阻塞 + 边缘触发 + EPOLLONESHOT；
> - 数据就绪：epoll检测到客户端socket可读，主线程读取数据到缓冲区；
> - 任务派发：HTTP请求读取完整后，将`process()`封装为std::function加入线程池；
> - 响应写回：工作线程处理完成后，主线程通过epoll检测EPOLLOUT事件写回响应。
>
> **关键技术**
>
> - 边缘触发(ET) + 非阻塞I/O：避免惊群效应，提高效率；
> - EPOLLONESHOT：保证一个socket同一时刻只被一个线程处理；
> - 信号处理：SIGALRM信号通过管道通知主线程，触发定时器逻辑。

#### 3.2.2 并发层

> - 阻塞队列：生产者-消费者模型，使用条件变量 + 互斥锁实现；
> - 工作线程：启动时创建固定数量线程，循环从队列取任务执行；
> - 任务封装：使用`std::function<void()>`封装Lambda表达式，实现任意函数绑定。
>
> **优势**
>
> - 避免频繁创建/销毁线程的开销；
> - 限制并发线程数量，防止资源耗尽；
> - 支持异步任务执行，提升系统响应速度。

#### 3.2.3 解析层

> **主状态机 (CHECK_STATE)**
>
> - `CHECK_STATE_REQUESTLINE`：解析请求行 (方法 URL 版本)；
> - `CHECK_STATE_HEADER`：解析请求头 (Connection, Content-Length等)；
> - `CHECK_STATE_CONTENT`：解析请求体 (POST的JSON数据)，
>
> **从状态机 (LINE_STATUS)**
>
> - `LINE_OK`：读取到完整的一行 (\r\n)；
> - `LINE_BAD`：行格式错误；
> - `LINE_OPEN`：行数据不完整，需要继续读取。
>
> ```apl
> 读取数据 → 从状态机逐行解析 → 主状态机处理每一行
>          ↓
>     根据当前状态调用对应解析函数
>          ↓
>     状态转移 (请求行→请求头→请求体)
>          ↓
>     解析完成 → 返回GET_REQUEST → 调用GetRequestFile()
> ```

#### 3.2.4 存储层

| 引擎类型 | 数据结构 | 时间复杂度 | 容量 | 适用场景 | 线程安全 |
|---------|---------|-----------|------|---------|---------|
| **Array** | 线性数组 | 查找O(n), 插入O(1) | 512K | 小规模数据，测试场景 | 独立读写锁 |
| **Hash** | 链地址法哈希表 | 查找O(1), 插入O(1) | 128K桶 | 大规模快速查找 | 独立读写锁 |
| **RBTree** | 红黑树 | 查找O(log n), 插入O(log n) | 512K | 需要有序遍历 | 独立读写锁 |

为了保证线程安全，这里对 [kvstore源码](https://github.com/UtopianYouth/kvstore) 进行了修改。

> - 每个引擎独立配备`std::shared_mutex`读写锁；
> - 读操作（GET/EXIST）：使用`std::shared_lock`，多个线程可并发读；
> - 写操作（SET/DEL/MOD）：使用`std::unique_lock`，独占访问；
> - 不同引擎之间无锁竞争，可并发执行。
>

#### 3.2.5 定时器

> **数据结构**
>
> - 升序双向链表，按超时时间排序；
> - 每个客户端连接对应一个`UtilTimer`对象；
> - 定时器存储客户端socket信息和回调函数。
>
> **工作机制**
>
> - 新连接建立时创建定时器，超时时间 = 当前时间 + 3 * TIMESLOT；
> - 客户端有数据到达时，调用`adjustTimer()`延长超时时间；
> - SIGALRM信号触发`tick()`函数，遍历链表检查超时连接；
> - 超时连接执行回调函数`cbFunc()`，关闭socket并释放资源。

### 3.6 线程同步

#### 3.6.1 问题

原kvstore项目基于**单线程 + 事件回调**的Reactor模型，未考虑多线程并发访问KV数据结构的线程安全问题。本项目采用**Reactor + 线程池**后，多个工作线程会并发访问全局KV数据结构（`global_array`、`global_hash`、`global_rbtree`），存在以下线程安全风险。

> - 数据竞争：多线程同时读写同一个键值对；
> - 内存损坏：链表/树结构在并发修改时指针混乱；
> - 数据不一致：读线程可能读到写线程修改到一半的脏数据。
>

#### 3.6.2 解决

> - 细粒度锁：每个KV引擎独立配备读写锁，避免不必要的锁竞争；
> - 读写分离：读操作使用共享锁并发执行，写操作使用独占锁；
> - 函数内加锁：锁的添加位置在每个数据结构的操作函数内部，而非`kvs_handler`层；
> - 性能优先：不同引擎之间无锁依赖，可并发执行。

## 四、测试

| 指标 | 数值 | 说明 |
|------|------|------|
| **并发连接数** | 10000+ | 基于epoll的高并发支持 |
| **QPS** | 10K~15K | 压测工具测试结果 |
| **响应延迟** | <10ms | 非阻塞I/O保证低延迟 |
| **线程池大小** | 4个工作线程 | 可配置，默认8线程 |
| **存储容量** | Array:512K, Hash:128K, RBTree:512K | 可通过宏定义调整 |

## 五、碎碎念

### 5.1 总结

本项目是一个完整的高性能KV存储演示系统，涵盖了Linux网络编程、并发编程、数据结构与算法等技术栈。

### 5.2 亮点

> 🌟 **Reactor&线程池**：主线程I/O复用 + 工作线程异步处理，充分利用多核CPU；
> 🌟 **零拷贝技术**：mmap + writev减少数据拷贝，提升静态文件响应性能；
> 🌟 **细粒度锁**：读写锁 + 独立锁策略，平衡并发性能与线程安全；
> 🌟 **状态机解析**：健壮的HTTP协议解析，支持长连接和短连接；
> 🌟 **多引擎存储**：提供三种不同特性的KV引擎，满足不同场景需求。

### 5.3 优化

优化就是不断的抄Redis存在的扩展功能，感觉以下功能不错诶。

> - [ ] 支持持久化存储（日志文件、数据快照）；
> - [ ] 实现主从复制和数据备份机制；
> - [ ] 支持更多数据类型（List、Set、Sorted Set）；
> - [ ] 引入协程优化并发性能。
>





